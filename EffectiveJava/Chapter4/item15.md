## 15 변경 가능성을 최소화 하라
### 15.1 변경 불가능 클래스 생성 규칙
> - 객체 상태를 변경하는 메서드를 제공하지 않는다.
> - 계승할 수 없도록 한다.
> - 모든 필드를 final로 선언한다.
> - 모든 필드를 private로 선언한다.
> - 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.

### 15.2 함수형 접근법
```java
public final class Complex{
	private final double re;
	private final double im;
	
	public Complex(double re, double im){
		this.re = re;
		this.im = im;
	}
	
	public Complex add(Complex c){
		return new Complex(re + c.re, im + cim);
	}
	...
}
```
위 코드의 add 함수처럼 this 객체를 변경하는 대신 새로운 Complex 객체를 만들어 반환하도록 구현하는 방법을 함수형 접근법(functional approach)라고 한다.</br>익숙하지 않은 상태에서는 부자연스러워 보일 수 있지만 객체 수정이 불가능하기 때문에 스레드에 안전(thread-safe)하고 동기화가 필요없다. 또한 다른 객체와 자유롭게 공유해도 문제가 발생하지 않는다.

변경 불가능 클래스는 클라이언트가 기존 객체를 재사용하도록 적극 장려하는것이 중요한데 정적 팩터리 메서드를 제공하면 쉽게 캐시 기능을 추가할 수 있다.

### 15.3 변경 불가능 클래스의 장/단점
#### 15.3.1 변경 불가능한 객체는 그 내부도 공유할 수 있다.
BigInteager 클래스의 경우 값의 부호와 크기를 int 변수와 int배열로 표현하는데 negate 메서드는 같은 크기의 값을 부호만 바꿔서 새로운 BigInteager 객체로 반환한다. 하지만 배열은 복사하지 않고 기존 내부 배열을 사용한다.

#### 15.3.2 변경 불가능한 객체는 다른 객체의 구성요소로도 훌륭하다.
객체가 복잡하다 하더라도 객체는 변하지 않기 때문에 맵의 키나 집합의 원소로 사용하기 좋다.

#### 15.3.3 값마다 별도의 객체를 만들어야 한다.
변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 하기 때문에 객체 생성 비용이 높을 가능성이 있다. 특히 객체가 클수록 그 여파가 심해지는데 