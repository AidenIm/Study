## 7 종료자 사용을 피하라
**종료자(finalizer)는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.**
종료자는 C++의 소멸자(destructor)와는 다르다는 것을 유념해야한다.
C++에서의 소멸자는 객체의 자원을 반환하는 일반적인 수단이지만 자바에서는 GC가 알아서 사용하지 않는 객체를 반환하므로 
프로그래머 입장에서 특별히 해줘야하는 일이 없다. 
 
### 7.1 단점
####7.1.1 종료자는 즉시 실행되리라는 보장이 전혀 없다
따라서 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다.

예를 들어 종료자안에서 파일을 닫도록 하면 치명적일 수 있다.
종료자가 실행되기 전 열려있는 파일이 많이 남아있을 수 있고 파일 기술자(file descriptor)는 유한한 자원이기 때문에 파일을 새로 열려고 시도할 때 실패할 수 있다.

#### 7.1.2 종료자의 실행 시점은 JVM에 종속 적이다.
JVM에서 종료자 스레드의 우선 순위가 낮게 설정되어 있는 경우 다른 응용프로그램(application)을 처리하기 위해
종료자가 실행되지 못하고 계속 큐에 쌓여 OutOfMemoryError를 발생시킬 수 있다.
이것은 매우 극단적인 상황이지만 자바 명세서(specification)에는 
종료자가 어떤 스레드에서 실행되어야 하는지에 대한 내용이 없기 때문에 위 문제를 완벽히 피하기 위해서는 종료자 사용을 피해야 한다.

#### 7.1.3 종료자는 실행되지 않을 수 있다
자바 명세서에는 종료자가 즉시 실행되어야 한다는 문구도 없지만, 종료자가 반드시 실행되어야 한다는 문구도 없다.
그러므로 지속성이 보장되어야 하는 **중요 상태 정보(critical persistent state)는 종료자로 갱신하면 안 된다.**
예를 들어 데이터베이스 같은 공유 자원에 대한 지속성 락(persistent lock)을 종료자가 반환하게 구현하면 분산 시스템(distributed system) 전체를 먹통으로 만들 수 있다.

#### 7.1.4 종료자 안에서 예외는 비결정적(undeterministic)이다
종료 처리 과정에서 무점검(uncaught) 예외가 던져지면, 해당 예외는 **무시**되며 종료 과정은 중단된다. 
일반적으로 무점검 예외가 발생하면 스레드는 종료되고 스택 정보(stack trace)가 표시되지만, 종료자 안에서는 경고문구도 출력되지 않는다.

#### 7.1.5 종료자를 사용하면 성능이 심각하게 떨어진다.
종료자를 사용해 객체를 삭제하는 프로그램을 만들면 종료자를 사용하지 않는 프로그램에 비해 성능이 수백배까지 느려질 수 있다.
<br/>
### 7.2 해결 방안
#### 7.2.1 명시적인 종료 메서드 사용하기
private 필드 값을 하나 두고 클래스에 명시적 종료(termination method)를 정의해 명시적으로 삭제하거나 반환된 자원임을 알수 있게 한다.
다른 모든 메서드에서는 private 필드의 값을 체크해 유효한 객체인지 판단 후 유효하지 않다면 IllegalStateException을 던지는 등의 예외를 발생시켜야 한다.
OuputStream이나 InputStream의 close나 java.util.Timer의 cancel이 이런 메서드의 대표적인 예인데 반환 메서드를 호출하지 않을 경우 심각한 성능 저하를 초래할 수 있으므로 주의해야 한다.
이런 명시적 종료 메서드들은 보통 try-finally를 사용해 객체 종료를 보장한다. 
자바 1.7부터는 try-with-resource문 사용으로 finally를 사용하지 않을 수 있다.

<br/>
### 7.3 종료자 이용방법
#### 7.3.1 명시적 종료 메서드를 호출하기 위한 안전망
명시적 종료 메서드 호출을 잊더라도 종료자를 통해 명시적 종료 호출 메서드가 호출 될 수 있도록 하는 방법이 있다.
하지만 이런 상황은 일반적이지 않은 버그 상황으로 인지 되어야 하며 반드시 로그를 남겨 이후 명시적 종료 메서드가 호출되지 않는 경우가 없도록 수정해야한다.
종료자로 이런 안정망을 구현할 때는 추가적인 비용을 감당하면서 구현할 만한 가치가 있는 일인지 신중하게 검토 후 구현해야 한다.

#### 7.3.2 네이티브 피어(native peer)와 연결된 객체 다루기
네이티브 피어는 일반 자바 객체가 네이티브 메서드 (native method)를 통해 기능 수행을 위임하는 네이티브 객체를 말한다. 
네이티브 피어는 일반 객체가 아니므로 GC가 알 수 없고 자바쪽 피어 객체가 반환될 때 같이 반환할 수도 없다. 
네이티브 피어가 **중요한 자원을 점유하고 있지 않다면** 종료자를 사용해 반환할 수 있다.
하지만 네이티브 피어가 즉시 종료 되어야 하는 자원을 포함한 경우에는 앞서 말한 명시적인 종료 메서드를 클래스에 추가해 자원을 반환하게 해야한다.

### 7.4 주의할 점
#### 7.4.1 종료자 연결(finalizer chaining)은 자동으로 이루어지지 않는다.
만일 (Object가 아닌) 클래스가 종료자를 가지고 있고 하위 클래스가 해당 메서드를 재정의 한다면 하위 클래스의 종료자는 상위 클래스의 종료자를 명시적으로 호출 해야 한다.
``` java
@Override protected void finalize() throws Thowable
{
	try
	{
		//...
	}
	finally
	{
		super.finalize();
	}
}
```
이처럼 하위 클래스에서 상위 클래스 종료자를 재정의(override)하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는데 이런 문제를 방지하기 위한 한가지 방법은 클래스 내부에 종료 보호자(finalizer guardian)을 만드는 것이다.

```java
public class Foo
{
	private final Object finalizerGuardian = new Object()
	{
		@Override protected void finalize() throws Throwable
		{
			//...
			// 바깥 Foo 객체를 종료 시킴
		}
	}
}
```

종료 보호자를 참조하는 finalizerGuardian 필드가 private이기 때문에 외부 객체(Foo)에 대한 참조가 모두 사라지는 순간 finalizerGuardian의 finalizer가 호출된다.