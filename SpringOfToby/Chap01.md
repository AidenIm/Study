# 토비의 스프링

## Chap1

### 개방 폐쇄의 원칙(OCP)

클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다

> 개방 폐쇄의 원칙은 객체지향 설계 원칙 SOLID의 하나로 SOLID는 아래 5가지 원칙의 첫머리를 따서 만들었다.
>
> - SRP(The Single Responsibility Priciple) : 단일 책임 원칙
> - OCP(The Open Closed Principle) : 개방 폐쇄 원칙
> - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙
> - ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙
> - DIP(The Dependenty Inversion Principle) : 의존관계 역전 원칙

#### 높은 응집도와 낮은 결합도

##### 높은 응집도

- 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다

##### 낮은 결합도

- 책임과 관심사가 다른 오브젝트 또는 모듈과 느슨하게 연결된 형태를 유지하는 것이 바람직하다.


### 제어의 역전(IoC)

프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다. 프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 다른 모든 오브젝트는 위임받은 권한을 받는 오브젝트에 의해 결정되고 만들어진다.

템플릿 메소드 패턴이나 프레임워크에서 제어의 역전을 확인할 수 있다.
 - 템플릿 메소드 패턴에서 상위 클래스의 함수를 하위 클래스에 작성할 때 우리는 이 함수가 언제 어떻게 호출될지 알 수 없다.
 - 프레임워크 또한 사용자가 작성한 어플리캐이션 코드가 프레임워크에 의해 수동적으로 동작한다. 

> 프레임워크와 라이브러이가 혼용되어 사용되는 경우가 빈번한데 IoC가 적용되지 않았다면 프레임워크라고 할 수 없다. 
>
> 라이브러리는 사용자가 작성한 코드 내에서 라이브러리의 특정 기능을 사용에 직접 제어하게 되어 IoC가 적용되지 않는다.



### 디자인 패턴

#### 전략 패턴

OCP에 가장 잘 들어맞는 패턴으로 자신의 Context에서 필요에 따라 변경이 필요한 로직을 인터페이스를 통해 통째로 외부로 분리시켜 구현하는 패턴

#### 템플릿 메소드 패턴

변하지 않는 기능은 슈퍼클래스에서 만들어두고 확장할 기능은 훅(hook) 메소드 [^1] 만들어 서브클래스에서 구현하도록 한다.


#### 팩토리 메소드 패턴

슈퍼클래스에서 서브클래스가 구현할 메소드를 호출해 오브젝트를 얻은 후 해당 오브젝트를 사용하는 패턴이다. 서브클래스가 반환하는 오브젝트는 보통 인터페이스 타입으로 어떤 클래스가 반환될지는 알 수 없다.

#### 싱글톤 패턴

애플리케이션 전체에서 특정 클래스가 하나만 존재하도록 강제하는 패턴이다. 단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.

### 오브젝트의 동일성과 동등성

- 동일성 : 두 오브젝트가 **완전히 동일**한가를 판단하며 **==** 연산자가 동일성 확인에 사용된다.
- 동등성 : 두 오브젝트가 **동일한 정보**를 담고 있는가를 판단하며 **equals()** 메소드가 동등성 확인에 사용된다.

> 동일한 오브젝트는 동등한 오브젝트이기도 하지만 그 반대는 참이 아니다.

### 싱글톤 레지스트리

스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관히라는 기능을 제공하는데 이를 **싱글톤 레지스트리**라고 한다. 일반적으로 사용하는 싱글톤 패던과 달리 사용자는 일반적인 형태 [^2] 로 클래스를 만들 수 있기 때문에 객체지향적인 설계가 가능하다.

#### 주의할 점

멀티스레드 환경에서는 여러 스레드가 동시에 접근할 수 있기 때문에 인스턴스 변수를 수정하는 것은 매우 위험하다. 싱글톤이 멀티스레드 환경에서 사용되는 경우, 무상태(Stateless) 방식으로 만들어야 하며 읽기 전용이 아닌 인스턴스 변수는 만들지 않는 것이 좋다.

#### 스프링 빈의 스코프

스코프(scope) : 스프링이 관리하는 오브젝트(bean)가 생성되고 존재하고 적용되는 범위

- 싱글톤 스코프 (singleton scope) : 컨테너 대에 한 개만 존재, 강제로 제거하지 않는 이상 계속 유지됨
- 프로토타입 스코프 (prototype scope) : 빈을 요청 할 때마다 매번 새로운 오브젝트를 만들어줌
- 요청 스코프 (request scope)
- 세션 스코프 (session scope)

### 의존관계 주입(Dependency Injection, DI)

#### 의존관계

의존관계인 클래스 A ─ ─＞B[^3]가 있다고 했을 때, B가 변하면 A에 영향을 미친다는 것을 의미한다. 

의존관계는 방향성이 있어 위 같은 경우 A가 B의 의존하고 있지만, B는 A에 의존하고 있지 않다.

#### 의존관계 주입의 충족 조건

- 클래스 모델이나 런타임 시점의 의존 관계가 드러나지 않는다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 **제3의 존재**[^4]가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에 제공해서 만들어진다.

### 의존관계 검색(Dependency Lookup, DL)

외부로부터의 주입이 아니라 스스로 검색을 통해 의존관계를 맺는 방법

> 의존관계 주입과 동일하게 외부 DI컨테이너를 통해 의존관계를 맺지만 접근할 DI컨테이너를 함수/생성자를 통해 주입받지 않고 자신이 직업 요청하는 방법

### 의존관계 주입과 검색

특정 클래스에 DI가 적용되기 위해서는 DI를 적용하기 위한 클래스와 DI컨테이너가 모두 Bean 오브젝트여야 한다. 스프링 컨테이너가 특정 클래스 A에 DI를 주입하기 위해서는 A클래스의 생성과 초기화 권한이 필요하기 때문이다.

하지만 DL은 DI와 다르게 DI컨테이너를 호출하는 자신이 Bean객체일 필요가 없어 테스트코드나 서버에서도 사용할 수 있다.

> 테스트 코드의 경우 main 함수를 사용하는데 이때 main함수는 DI를 통해 오브젝트를 주입받을 수 없고 서버의 경우 main 함수와 비슷한 역할을 하는 서블릿을 불러오기 위해서는 DL을 한번 사용해야 한다.



[^1]: 싱글톤 패턴으로 클래스를 구현하면 생성자가 private를 사용하고 내부적으로 static 멤버를 사용하고 있어 확장이 힘들다.

[^2]: hook 메소드 : 슈퍼클래스에서는 기본 기능을 지정하거나 비워두고 서브클래스에서 추상 메소드 구현이나 오버라이드를 통해 기능을 확장하도록 하는 메소드

[^3]: 점선 화살표는 클래스 다이어그램의 의존관계 연결을 의미한다.
[^4]: 이렇게 런타임 의존관계 주입을 주도하는 컨테이터를  IoC컨테이너 혹은 DI컨테이너라고 부른다.

 